# 前端面试内容

1. Js实现继承  
    1. 原型链模式：把父类的`实例`作为子类的`原型`（也可以把父类的`原型`作为子类的`原型`)
        * 添加子类方法必须在`new son()`之后才可以
        * 对于父类对象的引用是所有子类共享的
        * 创建子类实例时候，无法向父类传递参数
        ```
            function Cat(){ 
            }
            Cat.prototype = new Animal();
            Cat.prototype.name = 'cat';
        ```
    2. 使用构造函数： 在子类中使用`call`得到子类对象
        * 只能继承父类的实例方法和属性，无法获得其原型方法
        * 无法实现函数复用， 每个子类都有父类实例副本。
        ```
        function Cat(name){
            Animal.call(this);
            this.name = name || 'Tom';
        }
        ```
    3. 实例继承： 把父类作为结果返回，修改父类的属性
        * 实例是父类的实例，不是子类的实例
        * 不支持多继承
        ```
        function Cat(name){
            var instance = new Animal();
            instance.name = name || 'Tom';
            return instance;
        }
        ```
    4. 拷贝继承： 遍历父类的属性，复制到子类中
        * 父类中不可遍历的属性无法获得
        * 效率低下
        ```
        function Cat(name){
            var animal = new Animal();
            for(var p in animal){
                Cat.prototype[p] = animal[p];
            }
            Cat.prototype.name = name || 'Tom';
        }
        ```
    5. 组合继承： 先用`2`中构造函数获得实力方法和属性，再用`1`中方法定义子类的原型
        * 调用了两次父类的构造函数
        ```        
        function Cat(name){
            Animal.call(this);
            this.name = name || 'Tom';
        }
        Cat.prototype = new Animal();
        ```
    6. 寄生组合继承： 先去掉父类的实例属性，就不需要调用两次了
        * 实现复杂
        ```
        function Cat(name){
            Animal.call(this);
            this.name = name || 'Tom';
        }
        (function(){
            // 创建一个没有实例方法的类
            var Super = function(){};
            Super.prototype = Animal.prototype;
            //将实例作为子类的原型
            Cat.prototype = new Super();
        })();
        ```